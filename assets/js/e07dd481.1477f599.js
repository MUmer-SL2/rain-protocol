"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[7177],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return d}});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var o=a.createContext({}),h=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=h(e.components);return a.createElement(o.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,s=e.originalType,o=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=h(t),d=i,m=u["".concat(o,".").concat(d)]||u[d]||p[d]||s;return t?a.createElement(m,l(l({ref:n},c),{},{components:t})):a.createElement(m,l({ref:n},c))}));function d(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var s=t.length,l=new Array(s);l[0]=u;var r={};for(var o in n)hasOwnProperty.call(n,o)&&(r[o]=n[o]);r.originalType=e,r.mdxType="string"==typeof e?e:i,l[1]=r;for(var h=2;h<s;h++)l[h]=t[h];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},7386:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return r},contentTitle:function(){return o},metadata:function(){return h},toc:function(){return c},default:function(){return u}});var a=t(7462),i=t(3366),s=(t(7294),t(3905)),l=["components"],r={},o=void 0,h={unversionedId:"api/phased/Phased",id:"version-v0.0.10/api/phased/Phased",isDocsHomePage:!1,title:"Phased",description:"Phased is an abstract contract that defines up to 9 phases that",source:"@site/versioned_docs/version-v0.0.10/api/phased/Phased.md",sourceDirName:"api/phased",slug:"/api/phased/Phased",permalink:"/rain-protocol/v0.0.10/api/phased/Phased",tags:[],version:"v0.0.10",frontMatter:{},sidebar:"version-v0.0.10/tutorialSidebar",previous:{title:"TierUtil",permalink:"/rain-protocol/v0.0.10/api/libraries/TierUtil"},next:{title:"IBalancerConstants",permalink:"/rain-protocol/v0.0.10/api/pool/IBalancerConstants"}},c=[{value:"Details",id:"details",children:[]},{value:"Variables",id:"variables",children:[{value:"<code>uint32</code> <code>UNINITIALIZED</code>",id:"uint32-uninitialized",children:[]},{value:"<code>uint32[8]</code> <code>phaseBlocks</code>",id:"uint328-phaseblocks",children:[]}]},{value:"Events",id:"events",children:[{value:"<code>PhaseShiftScheduled(uint32 newPhaseBlock_)</code>",id:"phaseshiftscheduleduint32-newphaseblock_",children:[]}]},{value:"Modifiers",id:"modifiers",children:[{value:"<code>onlyPhase(enum Phase phase_)</code>",id:"onlyphaseenum-phase-phase_",children:[]},{value:"<code>onlyAtLeastPhase(enum Phase phase_)</code>",id:"onlyatleastphaseenum-phase-phase_",children:[]}]},{value:"Functions",id:"functions",children:[{value:"<code>phaseAtBlockNumber(uint32[8] phaseBlocks_, uint32 blockNumber_) \u2192 enum Phase</code> (public)",id:"phaseatblocknumberuint328-phaseblocks_-uint32-blocknumber_--enum-phase-public",children:[]},{value:"<code>blockNumberForPhase(uint32[8] phaseBlocks_, enum Phase phase_) \u2192 uint32</code> (external)",id:"blocknumberforphaseuint328-phaseblocks_-enum-phase-phase_--uint32-external",children:[]},{value:"<code>currentPhase() \u2192 enum Phase</code> (public)",id:"currentphase--enum-phase-public",children:[]},{value:"<code>scheduleNextPhase(uint32 nextPhaseBlock_)</code> (internal)",id:"schedulenextphaseuint32-nextphaseblock_-internal",children:[]},{value:"<code>_beforeScheduleNextPhase(uint32 nextPhaseBlock_)</code> (internal)",id:"_beforeschedulenextphaseuint32-nextphaseblock_-internal",children:[]}]}],p={toc:c};function u(e){var n=e.components,t=(0,i.Z)(e,l);return(0,s.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"Phased")," is an abstract contract that defines up to ",(0,s.kt)("inlineCode",{parentName:"p"},"9")," phases that\nan implementing contract moves through."),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"Phase.ZERO")," is always the first phase and does not, and cannot, be set\nexpicitly. Effectively it is implied that ",(0,s.kt)("inlineCode",{parentName:"p"},"Phase.ZERO")," has been active\nsince block zero."),(0,s.kt)("p",null,"Each subsequent phase ",(0,s.kt)("inlineCode",{parentName:"p"},"Phase.ONE")," through ",(0,s.kt)("inlineCode",{parentName:"p"},"Phase.EIGHT")," must be\nscheduled sequentially and explicitly at a block number."),(0,s.kt)("p",null,"Only the immediate next phase can be scheduled with ",(0,s.kt)("inlineCode",{parentName:"p"},"scheduleNextPhase"),",\nit is not possible to schedule multiple phases ahead."),(0,s.kt)("p",null,"Multiple phases can be scheduled in a single block if each scheduled phase\nis scheduled for the current block."),(0,s.kt)("p",null,"Several utility functions and modifiers are provided."),(0,s.kt)("p",null,"A single hook ",(0,s.kt)("inlineCode",{parentName:"p"},"_beforeScheduleNextPhase")," is provided so contracts can\nimplement additional phase shift checks."),(0,s.kt)("p",null,"One event ",(0,s.kt)("inlineCode",{parentName:"p"},"PhaseShiftScheduled")," is emitted each time a phase shift is\nscheduled (not when the scheduled phase is reached)."),(0,s.kt)("h2",{id:"details"},"Details"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"Phased")," contracts have a defined timeline with available\nfunctionality grouped into phases.\nEvery ",(0,s.kt)("inlineCode",{parentName:"p"},"Phased")," contract starts at ",(0,s.kt)("inlineCode",{parentName:"p"},"Phase.ZERO")," and moves sequentially\nthrough phases ",(0,s.kt)("inlineCode",{parentName:"p"},"ONE")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"EIGHT"),".\nEvery ",(0,s.kt)("inlineCode",{parentName:"p"},"Phase")," other than ",(0,s.kt)("inlineCode",{parentName:"p"},"Phase.ZERO")," is optional, there is no requirement\nthat all 9 phases are implemented.\nPhases can never be revisited, the inheriting contract always moves through\neach achieved phase linearly.\nThis is enforced by only allowing ",(0,s.kt)("inlineCode",{parentName:"p"},"scheduleNextPhase")," to be called once per\nphase.\nIt is possible to call ",(0,s.kt)("inlineCode",{parentName:"p"},"scheduleNextPhase")," several times in a single block\nbut the ",(0,s.kt)("inlineCode",{parentName:"p"},"block.number")," for each phase must be reached each time to schedule\nthe next phase.\nImportantly there are events and several modifiers and checks available to\nensure that functionality is limited to the current phase.\nThe full history of each phase shift block is recorded as a fixed size\narray of ",(0,s.kt)("inlineCode",{parentName:"p"},"uint32"),"."),(0,s.kt)("h2",{id:"variables"},"Variables"),(0,s.kt)("h3",{id:"uint32-uninitialized"},(0,s.kt)("inlineCode",{parentName:"h3"},"uint32")," ",(0,s.kt)("inlineCode",{parentName:"h3"},"UNINITIALIZED")),(0,s.kt)("h3",{id:"uint328-phaseblocks"},(0,s.kt)("inlineCode",{parentName:"h3"},"uint32[8]")," ",(0,s.kt)("inlineCode",{parentName:"h3"},"phaseBlocks")),(0,s.kt)("h2",{id:"events"},"Events"),(0,s.kt)("h3",{id:"phaseshiftscheduleduint32-newphaseblock_"},(0,s.kt)("inlineCode",{parentName:"h3"},"PhaseShiftScheduled(uint32 newPhaseBlock_)")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"PhaseShiftScheduled")," is emitted when the next phase is scheduled."),(0,s.kt)("h2",{id:"modifiers"},"Modifiers"),(0,s.kt)("h3",{id:"onlyphaseenum-phase-phase_"},(0,s.kt)("inlineCode",{parentName:"h3"},"onlyPhase(enum Phase phase_)")),(0,s.kt)("p",null,"Modifies functions to only be callable in a specific phase."),(0,s.kt)("h3",{id:"onlyatleastphaseenum-phase-phase_"},(0,s.kt)("inlineCode",{parentName:"h3"},"onlyAtLeastPhase(enum Phase phase_)")),(0,s.kt)("p",null,"Modifies functions to only be callable in a specific phase OR if the\nspecified phase has passed."),(0,s.kt)("h2",{id:"functions"},"Functions"),(0,s.kt)("h3",{id:"phaseatblocknumberuint328-phaseblocks_-uint32-blocknumber_--enum-phase-public"},(0,s.kt)("inlineCode",{parentName:"h3"},"phaseAtBlockNumber(uint32[8] phaseBlocks_, uint32 blockNumber_) \u2192 enum Phase")," (public)"),(0,s.kt)("p",null,"Pure function to reduce an array of phase blocks and block number to a\nspecific ",(0,s.kt)("inlineCode",{parentName:"p"},"Phase"),".\nThe phase will be the highest attained even if several phases have the\nsame block number.\nIf every phase block is after the block number then ",(0,s.kt)("inlineCode",{parentName:"p"},"Phase.ZERO")," is\nreturned.\nIf every phase block is before the block number then ",(0,s.kt)("inlineCode",{parentName:"p"},"Phase.EIGHT")," is\nreturned."),(0,s.kt)("h3",{id:"blocknumberforphaseuint328-phaseblocks_-enum-phase-phase_--uint32-external"},(0,s.kt)("inlineCode",{parentName:"h3"},"blockNumberForPhase(uint32[8] phaseBlocks_, enum Phase phase_) \u2192 uint32")," (external)"),(0,s.kt)("p",null,"Pure function to reduce an array of phase blocks and phase to a\nspecific block number.\n",(0,s.kt)("inlineCode",{parentName:"p"},"Phase.ZERO")," will always return block ",(0,s.kt)("inlineCode",{parentName:"p"},"0"),".\nEvery other phase will map to a block number in ",(0,s.kt)("inlineCode",{parentName:"p"},"phaseBlocks_"),"."),(0,s.kt)("h3",{id:"currentphase--enum-phase-public"},(0,s.kt)("inlineCode",{parentName:"h3"},"currentPhase() \u2192 enum Phase")," (public)"),(0,s.kt)("p",null,'Impure read-only function to return the "current" phase from internal\ncontract state.\nSimply wraps ',(0,s.kt)("inlineCode",{parentName:"p"},"phaseAtBlockNumber")," for current values of ",(0,s.kt)("inlineCode",{parentName:"p"},"phaseBlocks"),"\nand ",(0,s.kt)("inlineCode",{parentName:"p"},"block.number"),"."),(0,s.kt)("h3",{id:"schedulenextphaseuint32-nextphaseblock_-internal"},(0,s.kt)("inlineCode",{parentName:"h3"},"scheduleNextPhase(uint32 nextPhaseBlock_)")," (internal)"),(0,s.kt)("p",null,"Writes the block for the next phase.\nOnly uninitialized blocks can be written to.\nOnly the immediate next phase relative to ",(0,s.kt)("inlineCode",{parentName:"p"},"currentPhase")," can be written\nto.\nEmits ",(0,s.kt)("inlineCode",{parentName:"p"},"PhaseShiftScheduled")," with the next phase block."),(0,s.kt)("h3",{id:"_beforeschedulenextphaseuint32-nextphaseblock_-internal"},(0,s.kt)("inlineCode",{parentName:"h3"},"_beforeScheduleNextPhase(uint32 nextPhaseBlock_)")," (internal)"),(0,s.kt)("p",null,"Hook called before scheduling the next phase.\nUseful to apply additional constraints or state changes on a phase\nchange.\nNote this is called when scheduling the phase change, not on the block\nthe phase change occurs.\nThis is called before the phase change so that all functionality that\nis behind a phase gate is still available at the moment of applying the\nhook for scheduling the next phase."))}u.isMDXComponent=!0}}]);